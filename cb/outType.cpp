// Dump all outScript type


#include <util.h>
#include <common.h>
#include <errlog.h>
#include <string.h>
#include <callback.h>

typedef GoogMap<Hash160, uint64_t, Hash160Hasher, Hash160Equal>::Map TypeMap;

struct OutType:public Callback
{
    optparse::OptionParser parser;

    uint8_t *currHash;
    TypeMap typeMap;

    uint64_t bTime;

    uint64_t nbOutputs;
    uint64_t currBlock;
    uint64_t nThreshold;
    uint64_t nbDumped;
    const uint8_t *txStart;

    OutType()
    {
        parser
            .usage("[list of transaction hashes]")
            .version("")
            .description(
                "dumpp all the details of  the list of specified transactions"
            )
            .epilog("")
        ;
    }

    virtual const char                   *name() const         { return "outType"; }
    virtual const optparse::OptionParser *optionParser() const { return &parser;  }
    virtual bool                         needTXHash() const    { return true;     }
    virtual bool                         needEdge() const      { return false;     }
    virtual void aliases(
        std::vector<const char*> &v
    ) const {
        v.push_back("outtype");
    }


    virtual int init(
        int argc,
        const char *argv[]
    ) {
        nbDumped = 0;
        nThreshold = 1000;

        static uint8_t emptykey160[kRIPEMD160ByteSize] = { 0x52 };
        typeMap.setEmptyKey(emptykey160);

        const char *knownOutScriptTypes[] = {"000000000000000000000000000000ac884ba976",
                                             "000000000000000000000000000000000000ac4b",
                                             "0000000000000000000000000000000000874ba9",
                                             "0000000000000000000000000000747069726373",

                                             "00000000000000000000000000000000ae514b51",

                                             "000000000000000000000000000000ae524b4b51",
                                             "000000000000000000000000000000ae524b4b52",

                                             "0000000000000000000000000000ae534b4b4b51",
                                             "0000000000000000000000000000ae534b4b4b52",
                                             "0000000000000000000000000000ae534b4b4b53",
        };

        //do not dump detail of known script type, by setting threshold overflow.
        for(int i=0; i!=10; ++i)
          {
            const uint8_t *hexhash = (const uint8_t *)(knownOutScriptTypes[i]);
            uint160_t *type_new = (uint160_t *)allocHash160();
            fromHex(type_new->v, hexhash, kRIPEMD160ByteSize, true);
            typeMap[type_new->v] = nThreshold;
          }

        // test
        for(int i=0; i!=10; ++i)
          {
            const uint8_t *hexhash = (const uint8_t *)(knownOutScriptTypes[i]);
            uint160_t type;
            fromHex(type.v, hexhash, kRIPEMD160ByteSize, true);

            auto j = typeMap.find(type.v);
            if (typeMap.end() == j)
              {
                printf("!!! init hex, error: %d, %s\n", i, knownOutScriptTypes[i]);
                exit(0);
              }
          }
        return 0;
    }


    virtual void startBlock(
        const Block *b,
        uint64_t
    ) {
        currBlock = b->height;
        const uint8_t *p = b->chunk->getData();
        SKIP(uint32_t, version, p);
        SKIP(uint256_t, prevBlkHash, p);
        SKIP(uint256_t, blkMerkleRoot, p);
        LOAD(uint32_t, blkTime, p);
        bTime = blkTime;
    }


    virtual void startTX(
        const uint8_t *p,
        const uint8_t *hash,
        const uint8_t *txEnd
    ) {
        txStart = p;
        currHash = (uint8_t *)hash;
        nbOutputs = 0;
    }


    static void showScriptInfo(
        const uint8_t   *outputScript,
        uint64_t        outputScriptSize
    ) {
        uint8_t type[128];
        const char *typeName = "unknown";
        uint8_t pubKeyHash[kSHA256ByteSize];
        int r = solveOutputScript(pubKeyHash, outputScript, outputScriptSize, type);
        const char *script_type_name[] = {
          "broken script generated by p2pool - coins lost",
          "couldn't parse script",
          "pays to hash160(pubKey)",
          "pays to explicit uncompressed pubKey",
          "pays to explicit compressed pubKey",
          "pays to hash160(script)",
          "pays to hash160(script)",
        };
        if (r >= -2 && r <=4) {
          typeName = script_type_name[r+2];
        }
        printf("\n");
        printf("        script type = %s\n", typeName);

        if( 0<=r ) {
            uint8_t btcAddr[64];
            hash160ToAddr(btcAddr, pubKeyHash);
            printf("        script pays to address %s\n", btcAddr);
        }
    }


    virtual void endOutput(
        const uint8_t *p,                   // Pointer to TX output raw data
        uint64_t      value,                // Number of satoshis on this output
        const uint8_t *txHash,              // sha256 of the current transaction
        uint64_t      outputIndex,          // Index of this output in the current transaction
        const uint8_t *outputScript,        // Raw script (challenge to would-be spender) carried by this output
        uint64_t      outputScriptSize      // Byte size of raw script
    )
    {
      nbOutputs++;
      if (value==0) return;

      uint8_t type[20] = {0};

      int type_size = get_script_type(outputScript, outputScriptSize, type);
      auto j = typeMap.find(type);

      if (typeMap.end() != j) { //found
        if (j->second++ > nThreshold)
          return;
        printf("\n%s    type:", pr128(j->second).c_str());
      } else {
        uint160_t *type_new = (uint160_t *)allocHash160();
        memcpy(type_new->v, type, kRIPEMD160ByteSize);
        typeMap[type_new->v] = 1;
        printf("\n1    type:");
      }

      showHex(type, sizeof(uint160_t));
      struct tm gmTime;
      time_t blockTime = bTime;
      gmtime_r(&blockTime, &gmTime);

      char timeBuf[256];
      asctime_r(&gmTime, timeBuf);

      size_t sz =strlen(timeBuf);
      if(0<sz) timeBuf[sz-1] = 0;

      LOAD(uint32_t, version, p);

      printf("\ntxHash = ");
      showHex(currHash);
      printf("\n");
      printf("    version = %" PRIu32 "\n", version);
      printf("    minted in block = %" PRIu64 "\n", currBlock-1);
      printf("    mint time = %" PRIu64 " (%s GMT)\n", bTime, timeBuf);

      printf("        output[%" PRIu64 "] = %" PRIu64 "\n", nbOutputs-1, value);
      showScript(outputScript, outputScriptSize, 0, "        ");
      showScriptInfo(outputScript, outputScriptSize);

      ++nbDumped;
    }


    virtual void wrapup()
    {
        auto i = typeMap.begin();
        auto e = typeMap.end();
        printf("Found %" PRIu64 " different script types.\n", typeMap.size());
        printf("TYPE                                     N\n");
        printf("---------------------------------------- ----------\n");

        while(i!=e) {
          showHex(i->first, sizeof(uint160_t));
          printf(" %s\n", pr128(i->second).c_str());
          ++i;
        }
    }
};

static OutType outType;
